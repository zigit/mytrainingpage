////////////////////////////////////////////////////////////////////////////////
// The following FIT Protocol software provided may be used with FIT protocol
// devices only and remains the copyrighted property of Dynastream Innovations Inc.
// The software is being provided on an "as-is" basis and as an accommodation,
// and therefore all warranties, representations, or guarantees of any kind
// (whether express, implied or statutory) including, without limitation,
// warranties of merchantability, non-infringement, or fitness for a particular
// purpose, are specifically disclaimed.
//
// Copyright 2008 Dynastream Innovations Inc.
////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 1.0Release
// Tag = $Name: AKW1_000 $
////////////////////////////////////////////////////////////////////////////////


package com.garmin.fit;

import java.io.DataOutput;
import java.io.InputStream;
import java.io.DataInputStream;
import java.util.ArrayList;

public class Field {
   protected String name;
   protected int num;
   protected int type;
   protected double scale;
   protected double offset;
   protected String units;
   protected ArrayList<Object> values;
   protected ArrayList<FieldComponent> components;

   public Field(final Field field) {
      if (field == null) {
         this.name = "unknown";
         this.num = Fit.FIELD_NUM_INVALID;
         this.type = 0;
         this.scale = 1;
         this.offset = 1;
         this.units = "";
         this.values = new ArrayList<Object>();
         this.components = new ArrayList<FieldComponent>();
         return;
      }

      this.name = new String(field.name);
      this.num = field.num;
      this.type = field.type;
      this.scale = field.scale;
      this.offset = field.offset;
      this.units = new String(field.units);
      this.values = new ArrayList<Object>();
      for (Object value : field.values) {
         if (value instanceof Byte) {
            this.values.add(new Byte((Byte) value));
         } else if (value instanceof Short) {
            this.values.add(new Short((Short) value));
         } else if (value instanceof Integer) {
            this.values.add(new Integer((Integer) value));
         } else if (value instanceof Long) {
            this.values.add(new Long((Long) value));
         } else if (value instanceof Float) {
            this.values.add(new Float((Float) value));
         } else if (value instanceof Double) {
            this.values.add(new Double((Double) value));
         } else if (value instanceof String) {
            this.values.add(new String((String) value));
         }
      }
      this.components = field.components;
   }

   protected Field(String name, int num, int type, double scale, double offset, String units) {
      this.name = new String(name);
      this.num = num;
      this.type = type;
      this.scale = scale;
      this.offset = offset;
      this.units = new String(units);
      this.values = new ArrayList<Object>();
      this.components = new ArrayList<FieldComponent>();
   }
   
   public String getName() {
      return name;
   }

   public int getNum() {
      return num;
   }

   public String getUnits() {
      return units;
   }

   protected int getSize() {
      switch (type) {
         case Fit.BASE_TYPE_ENUM:
         case Fit.BASE_TYPE_UINT8:
         case Fit.BASE_TYPE_UINT8Z:
         case Fit.BASE_TYPE_SINT8:
         case Fit.BASE_TYPE_BYTE:
         case Fit.BASE_TYPE_SINT16:
         case Fit.BASE_TYPE_UINT16:
         case Fit.BASE_TYPE_UINT16Z:
         case Fit.BASE_TYPE_SINT32:
         case Fit.BASE_TYPE_UINT32:
         case Fit.BASE_TYPE_UINT32Z:
         case Fit.BASE_TYPE_FLOAT32:
         case Fit.BASE_TYPE_FLOAT64:
            return getNumValues() * Fit.baseTypeSizes[type & Fit.BASE_TYPE_NUM_MASK];

         case Fit.BASE_TYPE_STRING:
            return getStringValue().length() + 1;

         default:
            break;
      }

      return 0;
   }

   protected boolean isSignedInteger() {
      switch (type) {
         case Fit.BASE_TYPE_SINT8:
         case Fit.BASE_TYPE_SINT16:
         case Fit.BASE_TYPE_SINT32:
            return true;

         default:
            break;
      }

      return false;
   }

   public void addValue(Object value) {
      if ((value instanceof Number) && (type == Fit.BASE_TYPE_STRING)) {
         String string = getStringValue();
         Number number = (Number) value;

         if (string == null)
            string = "";

         string += String.valueOf((char) (number.intValue()));
         setValue(string);
         return;
      }

      values.add(value);
   }

   public int getNumValues() {
      return values.size();
   }

   public Object getValue() {
      return getValue(0);
   }

   public Object getValue(int index) {
      Object value;

      if (index >= values.size())
         return null;

      value = values.get(index);

      if ((value instanceof Number) && ((scale != 1) || (offset != 0))) {
         return new Double(((Number) value).doubleValue() / scale - offset);
      }

      return value;
   }

   public void setValue(Object value) {
      setValue(0, value);
   }

   public void setValue(int index, Object value) {
      while (index >= getNumValues())
         addValue(new Object());
      
      if (value == null) {
         values.set(index, null);
      } else if ((value instanceof Number) && ((scale != 1) || (offset != 0))) {
         values.set(index, (((Number) value).doubleValue() + offset) * scale);
      } else {
         values.set(index, value);
      }
   }

   public Long getBitsValue(int offset, int bits, boolean signed) {
      long value = 0;
      int bitsInValue = 0;
      int bitsInData;
      int index = 0;
      Long data;
      long mask;

      while (bitsInValue < bits) {
         data = getLongValue(index++);

         if (data == null)
            return null;

         data >>= offset;
         bitsInData = Fit.baseTypeSizes[type & Fit.BASE_TYPE_NUM_MASK] * 8 - offset;
         offset -= Fit.baseTypeSizes[type & Fit.BASE_TYPE_NUM_MASK] * 8;

         if (bitsInData > 0) {
            offset = 0;

            if (bitsInData > (bits - bitsInValue))
               bitsInData = bits - bitsInValue;

            mask = ((long) 1 << bitsInData) - 1;
            value |= ((long) data.longValue() & mask) << bitsInValue;
            bitsInValue += bitsInData;
         }
      }

      if (signed) {
         long signBit = (1L << (bits - 1));
         if ((value & signBit) != 0) {
            value = -signBit + (value & (signBit - 1));
         }
      }

      return value;
   }

   public Byte getByteValue() {
      return getByteValue(0);
   }

   public Byte getByteValue(int index) {
      Object value = getValue(index);

      if (value == null)
         return null;

      return ((Number) value).byteValue();
   }

   public Short getShortValue() {
      return getShortValue(0);
   }

   public Short getShortValue(int index) {
      Object value = getValue(index);

      if (value == null)
         return null;

      return ((Number) value).shortValue();
   }

   public Integer getIntegerValue() {
      return getIntegerValue(0);
   }

   public Integer getIntegerValue(int index) {
      Object value = getValue(index);

      if (value == null)
         return null;

      return ((Number) value).intValue();
   }

   public Long getLongValue() {
      return getLongValue(0);
   }

   public Long getLongValue(int index) {
      Object value = getValue(index);

      if (value == null)
         return null;

      return ((Number) value).longValue();
   }

   public Float getFloatValue() {
      return getFloatValue(0);
   }

   public Float getFloatValue(int index) {
      Object value = getValue(index);

      if (value == null)
         return null;

      return new Float(((Number) value).doubleValue());
   }

   public Double getDoubleValue() {
      return getDoubleValue(0);
   }

   public Double getDoubleValue(int index) {
      Object value = getValue(index);

      if (value == null)
         return null;

      return new Double(((Number) value).doubleValue());
   }

   public String getStringValue() {
      return getStringValue(0);
   }

   public String getStringValue(int index) {
      Object value = getValue(index);

      if (value == null)
         return null;

      return value.toString();
   }

   protected boolean read(InputStream in, int size) {
      try {
         DataInputStream data = new DataInputStream(in);
         int bytesLeft = size;

         while (bytesLeft > 0) {
            switch (type) {
               case Fit.BASE_TYPE_ENUM: {
                  Short value = (short) (data.readByte() & 0xFF);
                  if (!value.equals(Fit.ENUM_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_UINT8: {
                  Short value = (short) (data.readByte() & 0xFF);
                  if (!value.equals(Fit.UINT8_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_UINT8Z: {
                  Short value = (short) (data.readByte() & 0xFF);
                  if (!value.equals(Fit.UINT8Z_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_SINT8: {
                  Byte value = data.readByte();
                  if (!value.equals(Fit.SINT8_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_SINT16: {
                  Short value = data.readShort();
                  if (!value.equals(Fit.SINT16_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_UINT16: {
                  Integer value = data.readByte() & 0xFF;
                  value <<= 8;
                  value |= data.readByte() & 0xFF;
                  if (!value.equals(Fit.UINT16_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_UINT16Z: {
                  Integer value = data.readByte() & 0xFF;
                  value <<= 8;
                  value |= data.readByte() & 0xFF;
                  if (!value.equals(Fit.UINT16Z_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_SINT32: {
                  Integer value = data.readInt();
                  if (!value.equals(Fit.SINT32_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_UINT32: {
                  Long value = (long) (data.readByte() & 0xFF);
                  value <<= 8;
                  value |= data.readByte() & 0xFF;
                  value <<= 8;
                  value |= data.readByte() & 0xFF;
                  value <<= 8;
                  value |= data.readByte() & 0xFF;
                  if (!value.equals(Fit.UINT32_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_UINT32Z: {
                  Long value = (long) (data.readByte() & 0xFF);
                  value <<= 8;
                  value |= data.readByte() & 0xFF;
                  value <<= 8;
                  value |= data.readByte() & 0xFF;
                  value <<= 8;
                  value |= data.readByte() & 0xFF;
                  if (!value.equals(Fit.UINT32Z_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_STRING: {
                  String value = new String();
                  char c;

                  while (bytesLeft-- > 0) {
                     c = (char) data.readByte();
                     if (c == 0)
                        break;
                     value += c;
                  }

                  bytesLeft = 0; // String is array of character elements so we are done.

                  if (!value.equals(Fit.STRING_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_FLOAT32: {
                  Float value = data.readFloat();
                  if (!value.equals(Fit.FLOAT32_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_FLOAT64: {
                  Double value = data.readDouble();
                  if (!value.equals(Fit.FLOAT64_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_BYTE: {
                  Short value;
                  boolean invalid = true;

                  while (bytesLeft-- > 0) {
                     value = (short) (data.readByte() & 0xFF);
                     values.add(value);
                     if (!value.equals(Fit.BYTE_INVALID))
                        invalid = false;
                  }

                  if (invalid)
                     values.clear();
                  break;
               }

               default:
                  return false;
            }

            bytesLeft -= Fit.baseTypeSizes[type & Fit.BASE_TYPE_NUM_MASK];
         }
      } catch (java.io.IOException e) {
         return false;
      }

      return true;
   }

   protected int write(DataOutput out) {
      try {
         for (Object value : values) {
            if (value == null) {
               switch (type) {
                  case Fit.BASE_TYPE_ENUM:
                      out.writeByte(Fit.ENUM_INVALID);
                     break;
                  case Fit.BASE_TYPE_UINT8:
                       out.writeByte(Fit.UINT8_INVALID);
                     break;
                  case Fit.BASE_TYPE_UINT8Z:
                       out.writeByte(Fit.UINT8Z_INVALID);
                     break;
                  case Fit.BASE_TYPE_SINT8:
                       out.writeByte(Fit.SINT8_INVALID);
                     break;
                  case Fit.BASE_TYPE_BYTE:
                       out.writeByte(Fit.BYTE_INVALID);
                     break;
                  case Fit.BASE_TYPE_SINT16:
                     out.writeShort(Fit.SINT16_INVALID);
                     break;
                  case Fit.BASE_TYPE_UINT16:
                     out.writeShort(Fit.UINT16_INVALID);
                     break;
                  case Fit.BASE_TYPE_UINT16Z:
                     out.writeShort(Fit.UINT16Z_INVALID);
                     break;
                  case Fit.BASE_TYPE_SINT32:
                       out.writeInt(Fit.SINT32_INVALID);
                     break;
                  case Fit.BASE_TYPE_UINT32:
                       out.writeInt(Fit.UINT32_INVALID.intValue());
                     break;
                  case Fit.BASE_TYPE_UINT32Z:
                       out.writeInt(Fit.UINT32Z_INVALID.intValue());
                     break;
                  case Fit.BASE_TYPE_STRING:
                     out.writeByte(0);
                     break;
                  case Fit.BASE_TYPE_FLOAT32:
                     out.writeFloat(Fit.FLOAT32_INVALID);
                     break;
                  case Fit.BASE_TYPE_FLOAT64:
                     out.writeDouble(Fit.FLOAT64_INVALID);
                     break;
                  default:
                     return 0;
               }
            } else { // if (value != null)
               switch (type) {
                  case Fit.BASE_TYPE_ENUM:
                  case Fit.BASE_TYPE_UINT8:
                  case Fit.BASE_TYPE_UINT8Z:
                  case Fit.BASE_TYPE_SINT8:
                  case Fit.BASE_TYPE_BYTE: {
                     if (value instanceof String)
                        System.err.printf("Field.write(): Field %s value should not be string value %s\n", name, value);
                     out.writeByte(((Number) value).intValue());
                     break;
                  }
   
                  case Fit.BASE_TYPE_SINT16:
                  case Fit.BASE_TYPE_UINT16:
                  case Fit.BASE_TYPE_UINT16Z: {
                     out.writeShort(((Number) value).intValue());
                     break;
                  }
   
                  case Fit.BASE_TYPE_SINT32:
                  case Fit.BASE_TYPE_UINT32:
                  case Fit.BASE_TYPE_UINT32Z: {
                     out.writeInt(((Number) value).intValue());
                     break;
                  }
   
                  case Fit.BASE_TYPE_STRING: {
                     String string = value.toString();
                     for (int i = 0; i < string.length(); i++)
                        out.writeByte(string.charAt(i));
                     out.writeByte(0);
                     break;
                  }
   
                  case Fit.BASE_TYPE_FLOAT32: {
                     out.writeFloat(((Number) value).floatValue());
                     break;
                  }
   
                  case Fit.BASE_TYPE_FLOAT64: {
                     out.writeDouble(((Number) value).doubleValue());
                     break;
                  }
   
                  default:
                     return 0;
               } // if (value != null)
            }
         }
      } catch (java.io.IOException e) {
         return 0;
      }

      return getSize();
   }
}